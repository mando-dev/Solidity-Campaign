pragma solidity ^0.4.17;

contract CampaignFactory {                  //pay attention: since we used msg.sender in our constructor func campaing: so whenever we call this Campaign func from antoehr contract(CampaignFactory) the msg.sender will be our contract not our user(for safety reasons)      minimum contribution the campaing expects below
         address [] public deployedCampaigns;              //holds list of all deployed campaigns. the manager is going to be marked as our factory address. //manager will be marked as our factory address-so this is why we are passing in 
     
         function createCampaign(uint minimum) public {   //allows user to create new instance of a campaign. this func is goint to need to take in one arg: so when someone crates a campaign we expect them to provide a Constructor arguemtn with a minimum amount of money(look down at func Campaign(uint minuum)) AND we are not expecting users to directly create a Campaign (for secuirty reasons) so the arg of minimum money will be passed into the constructor func of Campaign.  
                  address newCampaign = new Campaign(minimum, msg.sender); //msg.sender is the address of person trying to create new Campaign func instance once new contract is deployed it will return address of newly added Campgain, thus that address will be stored in address newCampagin. also provide any constructor args that this thing requires such as uint minimum. heres where the magic happens: we are instructing this CampaignFactory contract to deploy an instance of the Campaign contract below
                  deployedCampaigns.push(newCampaign);       //we will take this new address 'newCampaign' and add it to our array of deployedCampaigns above. We are using factory to create new instance of Campain func below. 
                  }
                  function getDeployedCampaigns() public view returns (address[]) { //func that returns list of created camppaigns. it takes in no args but does return addresses. public means anyonw can call this func. view means that no data inside this factory contrract is modified by this func. returns means we will return address of type array.
                           return deployedCampaigns; //notice how deployedCampaigns was initialized above. we gonna take these deployed campaign addresses and use on front end web3. This func helps us see location of campaigns. 
                           }     //from now on we are not creating Campaigns (as below) directly but are being created by the Campaign factory
                  }

contract Campaign {               //request struct is a reference type data //H
         struct Request {          //defining our struct//this does not create instances for the whole Campaign, so these vars are onlu called in inside this struct definition
                    string description;    //adding fields
                    uint  value;            //unint=unsigned int
                    address recipient;      // u can think of struct as a type of definition or type, but not an instance of a var as the three below. 
                    bool complete;        //this is a complete flag. this doesn not create an instance of a struct, it just creates an idea of one
                    uint approvalCount;    //this field keeps tracks of YES VOTES that this request has received.
                    mapping(address => bool) approvals;     //FIRST. approvals here is a poperty .we can use this var to see if a particular has voted on somethign yet. //mappings is a reference type and not a value type like the vars above.//approvals mappings fields //approvals here is the ppl who have approved the Request here in the struct //mapping that will track whethere not someone has voted on a given request
                    }                                //manafer is person asking for donations     
            Request[] public requests;             //FIRST. these are our only 'storage' variables.array that specifically holds vars of type requests. making new array and specifying its type Request. we gave it the name 'reequests' . Thus inside our contract,we can make reference to this.This auto creates our 'array-getters' = requests()   
            address public manager;                  //manager manages Campaign. we want everyone to know whom the managers adddress is. these are "contract-level-variables"
            uint public minimumContribution ;           //all thse variables here are tied to the contract //initializing the variable //these vars can be accessed anywerhe in the contract
            mapping(address => bool) public approvers;             //'approvers' is just labeling the variable,'address' is writing out the type of key that we want to have          //ONly for arrays:  initializing approvers var as an array of addresses//all these vars hwere are pieces of data stored in our contract storage
            uint public approversCount;                      //FIRST(donate) init fo approversCount. after we add that persons address to our mapping inside the contribute func-approvers[msg.sender]= true =mapping//approversCount will go up everytime someone DONATES to Campaign//this is a state variable to track how many people have joined this contract. 
            
            modifier restricted() {                         //this is a func modifier. basically this is here for security so a fraud hacker doesnt make fake money requests and is sent paid out to bad guy. the func modifier should b wirtten above our contruct func. This func modifier will be used again during our finalizing payment method. 
                     require(msg.sender == manager);      //only manager can create a new spending request                //making sure that person sending request is the same person as the mananger and not a fraudster who can suck the money out the contract. Money will exist in the contract
                     _;                                    //whatever func we want to be modified will be virtually pasted so we dont repeat ourselves. we would not add modifier to contribute since we want anyone 
                     }
                function Campaign(uint minimum, address creator) public {   //we are passing in 'address' arg from our CampaignFactory. 'creator' was made on the the fly here as the person whose trying to create the new contract.  this is a constructor func. example of memory data. arguments to our funcs are mempry data. For example, when a func is called, it will temporarily use the args it is passed to and discard them onece done. Those args are lost sicne we can rerference to them anymore//when someone is calling new instance of the campaign, they shoul be passing in uint minimum//taking contribution argument into constructor func,   //constructor function/ sender property describes who is trying to create the contract// constructor func
                         manager = creator;               //this sets up the manager of our contract. diffrnt ppl might have different minium ether requirements,thus sender will be set on the fly     //assigning contract to manager// msg = message which is  a given variable/global variable
                         minimumContribution = minimum;   //line above 'creator' was changed from msg.sender in order to store the address of the person whom created the new contract
                         }
                function contribute() public payable {                          //. payable is what makes this func able to receive some kind of money. whenever anyone sends money to our contract. marking it as apayable function
                         require(msg.value > minimumContribution);   //making sure monyis morethan enouigh. one of the properties of msg is value-since msg is gobal variable 
                         approvers[msg.sender]  = true;              //this line of code lets us know if someone has contributed to the contract//key we are trying to look at is 'sender'. so tthis adds a new key to this address "msg.sender" to the approvers mapping and gives it a value of true. Remember that mappings doesnt store addresses, it will only store the value of 'true' in order to let us know that the approvers mapping is recognizing that that address is true to be an approver   //Only for arrays: we need to get the address of whom is sending the money whichh is coming from our globbal variabble msg !!!!!!!//msg is used multiple times throughtout the contract but this msg is referring to //so if user gets passed the line of code above then they can be added array of approvers
                         approversCount++;                          //once address of Campaign donater has donated, they will be added to mapping line directly above and our ticker goes up of approversCount++ 
                         }
                function createRequest(string description, uint value, address recipient) public restricted {                 //but we want to lock the func down by using th restricted modifier .these arguments come from first initializing Request struct way above. .purpose of this is to crate a new strcut of type Request .manager asking for spending request. public since it shoul be able to called by an externa account  //to make a request, you must have donated first to the contract: this will look up our approvers mapping, access the key ('sender') of this address inside of it '[msg.sender]', so if this address is tru that they have donated before, then the value should retrun true and and the require() just double makes sure that this is tru
                         Request memory newRequest = Request ({                                     //crateing our new request. this is an instance Request, the first word Request is just a 'get-ready' signn that a Request instance is going to b creatd
                                                              description: description,                 // key value pairs, field: value
                                                              value: value,                      //we are using memory here because when we crate a local variable/object Request-it automatically gets created in memeory because our new var 'newRequest' cant point to a version of 'newRequest' in storage (just like our storeage vars way above), so this var can only refer to this value object Reuest({}) that lives in memory
                                                              recipient: recipient,
                                                              complete: false,                   //complete flag should be false beacuse it is not yet ready to be completed
                                                              approvalCount: 0
                                                              });   
                                                              requests.push(newRequest);                 //take this whole new request and it to our request array
                                                              }
                function approveRequest(uint index) public {           //provingint uint to specify which request we are voting yes on. index is a made up name we made here. this is the index of the request we are trying to approve // we identify unique requests by identifying them via their index
                                                            Request storage request = requests[index];    //we want to manipulate this copy of the struct that exists inside of storage. we are naming this on the fly 'request' and it will be coming from requests[index]. and this is why we use the storage keyowrd since we dont want to copy it over to memory. .we are creating a local variable since we seem to repeat ourselves with accessong the requests[index]-mapping
                                                            require(approvers[msg.sender]);                  //<-- making sure that this person is a donator-so we are requiring that inside this approvers mapping:that if we pass in msg.sender-we shoudl get a boolean of true.if we get back false, func will exit instantly.//we are writing 2 quick checks: first, we gotta make sure he has already donated to our contract, check 2 is to check that this person has not already approved the already given request. 
                                                            require(!request.approvals[msg.sender]);   //accessing approvals property-and inside this thing we will see the address if either they have voted or not .making sure they have not voted on the this particular request before. we are looking at the request struct array at the given index. this request struct here has an approvals property-just look at above struct when we initialized 
                                                            request.approvals[msg.sender] = true;       //refactored: so if this sender ever calls agqin this approveRequest, we would be able to track him via his index and thus he would fail the 2nd requirement.approvals=approvals mapping.a way to  mark that this person has voted in this particular request
                                                            request.approvalCount++;                   //every request object here has an approvalCount value. refactored: incrementin our approval count as well. //logic for adding persons address to the approvals-mapping and then increment our arrpoval count (voting system)  
                                                            }                                              //require() are always seeking for true or false-thats their main job.APPROVERS=have voted, requsts(to spend money) done by manager. each request has its own voting// constant time look ups are not the same as iterating on arrays.
                function finalizeRequest(uint index) public restricted {       //when someone calls this func they have to inclusde index(argument) (request id) so we know which request. we added restricted' modifier because we only want managert to call this. manager can call this once enough votes are in 
                         Request storage request = requests[index];         //capitol R here referes that we are baout to create a var that refers to a Request sstruct. refactoring our code. storage key word because we want this specific var 'request' looking at the exact same copy of Request(capitol R??)  inside of storage. 
                         require(request.approvalCount > (approversCount / 2));    //approvalCount form state var under struct. //comparing nnumbers of approvals this 'request' has (next to storage) against the total number of people who have contributed against the campaign 
                         require(!request.complete);                         //the require statement will fail when complete value is false. the ! flips the boolean from true to false. making sure the a request is not finalized twice. So when bool/compltete turns ture-then thats it-its been finlazied once. 
                         request.recipient.transfer(request.value);    //. the struct 'request' inside here holds the value amount of money we are trying to request . because reccipient is an address, we use the statement transfer and put in the amount of money that needs to be sent. once request is approved by at least half of ppl, then its ready to atttempt to be sent to recipien/vendor. 
                         request.complete = true;                 //we want set complete flag to true once we pay vendor-meaning after we make sure this particular request hasnt been already finalized, then we can basically start a request as false 
                         }     //deploying contracts to the network cost money-gas. one contract can deploy another contract. We never send user the source code. the factory contract creates an instance. user does not have direct access to the original Campaign Source Code since its wrapped aroune/protected by the Factory contract/address. 
                function getSummary() public view returns (uint, uint, uint, uint, address) {      //returns stats/summar of campaigns such as its ciontributors etc. its a 'view' because we are not changing any data inside of here
                    return (
                        minimumContribution, //from line 28
                        this.balance, //'this' is a reference to the contract itself. balance is the current money the contract has available.
                        requests.length,//all of our requests have been earlier stored in an array before.
                        approversCount,       //numbers of contributors. we had store before our approvers inside of a mapping (line 29) and mappings cannot have links associated with them. Line 30 holds the number of contributors we have 'appoversCount'                       
                        manager     //address of manager. now we gotta define our return types inside 'returns()'
                        );
                        } 
            
                function getRequestsCount() public view returns (uint) {//this is for another component 
                    return requests.length;
                                 }//memory/storage keyworads are very important-memory we use to make copy of data and storage to change data in genereal (mapping or structs) . study by-value passing vs by-reference passing data structures
                             }



                
                
                